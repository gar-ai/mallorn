/*
 * Mallorn-Lite: Minimal C library for edge model delta updates
 *
 * This header is auto-generated by cbindgen. Do not edit directly.
 *
 * Usage:
 *   uint8_t buffer[1024];
 *   mallorn_patcher_t patcher;
 *   mallorn_init(&patcher, buffer, sizeof(buffer));
 *   mallorn_set_source(&patcher, read_fn, source_ctx);
 *   mallorn_set_patch(&patcher, read_fn, patch_ctx);
 *   mallorn_set_output(&patcher, write_fn, output_ctx);
 *   while (mallorn_step(&patcher) == MALLORN_CONTINUE) { }
 *   mallorn_verify(&patcher, expected_hash);
 */

#ifndef MALLORN_H
#define MALLORN_H

#include <stdint.h>
#include <stddef.h>

/**
 * Opaque patcher context (256 bytes, stack-allocatable)
 *
 * Allocate this on the stack or in static memory.
 * Size is fixed and known at compile time.
 */
typedef struct mallorn_patcher_t {
    uint8_t _opaque[256];
} mallorn_patcher_t;

#define MALLORN_PATCHER_SIZE 256


/**
 * Magic number for streaming patch format: "MLLP" (Mallorn Lite Patch)
 */
#define PATCH_MAGIC 1347177549

/**
 * Streaming patch format version
 */
#define PATCH_VERSION 2

/**
 * Minimum buffer size required (1KB)
 */
#define MIN_BUFFER_SIZE 1024

/**
 * Result codes for mallorn operations
 */
typedef enum mallorn_result_t {
  /**
   * Operation completed successfully
   */
  OK = 0,
  /**
   * More work to do, call step() again
   */
  CONTINUE = 1,
  /**
   * Invalid patch format or data
   */
  ERROR_INVALID_PATCH = -1,
  /**
   * Hash verification failed
   */
  ERROR_HASH_MISMATCH = -2,
  /**
   * Buffer too small (need at least 1KB)
   */
  ERROR_BUFFER_TOO_SMALL = -3,
  /**
   * I/O error (read/write callback failed)
   */
  ERROR_IO = -4,
  /**
   * Operation was aborted
   */
  ERROR_ABORTED = -5,
} mallorn_result_t;

/**
 * Read callback function type
 *
 * Called to read data from source model or patch file.
 *
 * # Arguments
 * * `ctx` - User-provided context pointer
 * * `buf` - Buffer to read data into
 * * `max_len` - Maximum number of bytes to read
 *
 * # Returns
 * Number of bytes actually read (0 on EOF or error)
 */
typedef uintptr_t (*mallorn_read_fn)(uint8_t *ctx, uint8_t *buf, uintptr_t max_len);

/**
 * Write callback function type
 *
 * Called to write data to output model.
 *
 * # Arguments
 * * `ctx` - User-provided context pointer
 * * `buf` - Buffer containing data to write
 * * `len` - Number of bytes to write
 *
 * # Returns
 * Number of bytes actually written
 */
typedef uintptr_t (*mallorn_write_fn)(uint8_t *ctx, const uint8_t *buf, uintptr_t len);

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Initialize a patcher with a working buffer.
 *
 * # Arguments
 * * `patcher` - Pointer to caller-allocated MallornPatcher
 * * `buffer` - Pointer to working buffer (minimum 1KB)
 * * `buffer_size` - Size of buffer in bytes
 *
 * # Returns
 * * `MALLORN_OK` - Initialization succeeded
 * * `MALLORN_ERROR_BUFFER_TOO_SMALL` - Buffer is less than 1KB
 *
 * # Safety
 * * `patcher` must be a valid, non-null pointer
 * * `buffer` must point to valid memory of at least `buffer_size` bytes
 * * Both pointers must remain valid until patching completes or is aborted
 */
enum mallorn_result_t mallorn_init(mallorn_patcher_t *patcher,
                                   uint8_t *buffer,
                                   uintptr_t buffer_size);

/**
 * Set source model read callback.
 *
 * # Arguments
 * * `patcher` - Pointer to initialized MallornPatcher
 * * `read_fn` - Callback function for reading source model data
 * * `ctx` - User context passed to callback
 *
 * # Safety
 * * `patcher` must be a valid, initialized MallornPatcher
 * * `read_fn` must be a valid function pointer
 * * `ctx` must remain valid for the duration of patching
 */
void mallorn_set_source(mallorn_patcher_t *patcher, mallorn_read_fn read_fn, uint8_t *ctx);

/**
 * Set patch file read callback.
 *
 * # Arguments
 * * `patcher` - Pointer to initialized MallornPatcher
 * * `read_fn` - Callback function for reading patch data
 * * `ctx` - User context passed to callback
 *
 * # Safety
 * * `patcher` must be a valid, initialized MallornPatcher
 * * `read_fn` must be a valid function pointer
 * * `ctx` must remain valid for the duration of patching
 */
void mallorn_set_patch(mallorn_patcher_t *patcher, mallorn_read_fn read_fn, uint8_t *ctx);

/**
 * Set output model write callback.
 *
 * # Arguments
 * * `patcher` - Pointer to initialized MallornPatcher
 * * `write_fn` - Callback function for writing output data
 * * `ctx` - User context passed to callback
 *
 * # Safety
 * * `patcher` must be a valid, initialized MallornPatcher
 * * `write_fn` must be a valid function pointer
 * * `ctx` must remain valid for the duration of patching
 */
void mallorn_set_output(mallorn_patcher_t *patcher, mallorn_write_fn write_fn, uint8_t *ctx);

/**
 * Execute one step of the patching process.
 *
 * Call this in a loop until it returns something other than `MALLORN_CONTINUE`.
 *
 * # Arguments
 * * `patcher` - Pointer to initialized MallornPatcher
 *
 * # Returns
 * * `MALLORN_OK` - Patching completed successfully
 * * `MALLORN_CONTINUE` - More work to do, call again
 * * Negative value - Error occurred
 *
 * # Example
 * ```c
 * while (mallorn_step(&patcher) == MALLORN_CONTINUE) {
 *     watchdog_reset();  // Pet the watchdog between steps
 * }
 * ```
 *
 * # Safety
 * * `patcher` must be a valid, initialized MallornPatcher
 * * I/O callbacks must have been set before first call
 */
enum mallorn_result_t mallorn_step(mallorn_patcher_t *patcher);

/**
 * Verify the patched output against expected hash.
 *
 * Call this after `mallorn_step()` returns `MALLORN_OK`.
 *
 * # Arguments
 * * `patcher` - Pointer to MallornPatcher that completed patching
 * * `expected_hash` - Pointer to 32-byte SHA256 hash to compare
 *
 * # Returns
 * * `MALLORN_OK` - Hash matches
 * * `MALLORN_ERROR_HASH_MISMATCH` - Hash does not match
 *
 * # Safety
 * * `patcher` must be a valid MallornPatcher
 * * `expected_hash` must point to at least 32 bytes
 */
enum mallorn_result_t mallorn_verify(const mallorn_patcher_t *patcher,
                                     const uint8_t *expected_hash);

/**
 * Abort the patching operation.
 *
 * Safe to call at any time. After calling this, the patcher
 * cannot be reused without calling `mallorn_init()` again.
 *
 * # Arguments
 * * `patcher` - Pointer to MallornPatcher
 *
 * # Safety
 * * `patcher` may be null (no-op in that case)
 */
void mallorn_abort(mallorn_patcher_t *patcher);

/**
 * Get the minimum required buffer size.
 *
 * # Returns
 * Minimum buffer size in bytes (1024)
 */
uintptr_t mallorn_min_buffer_size(void);

/**
 * Model fingerprint for quick version detection.
 *
 * Fingerprints sample the first 64KB (header) and last 4KB (tail) of a model,
 * enabling ~10ms version detection regardless of model size.
 */
typedef struct mallorn_fingerprint_t {
    uint64_t file_size;       /* Total file size in bytes */
    uint8_t header_hash[16];  /* MD5 of first 64KB */
    uint8_t tail_hash[16];    /* MD5 of last 4KB */
    uint8_t short_id[8];      /* XOR of header and tail (for quick comparison) */
} mallorn_fingerprint_t;

/**
 * Compute a fingerprint from a model file.
 *
 * This function samples the first 64KB and last 4KB of the model,
 * making it fast regardless of model size (~10ms for any size).
 *
 * # Arguments
 * * `read_fn` - Callback function for reading model data
 * * `ctx` - User context passed to callback
 * * `file_size` - Total size of the model file
 * * `fingerprint` - Output fingerprint structure
 *
 * # Returns
 * * `MALLORN_OK` - Fingerprint computed successfully
 * * `MALLORN_ERROR_IO` - Read callback failed
 *
 * # Safety
 * * `fingerprint` must point to valid memory
 * * `read_fn` must be a valid function pointer
 */
enum mallorn_result_t mallorn_fingerprint(mallorn_read_fn read_fn,
                                          uint8_t *ctx,
                                          uint64_t file_size,
                                          mallorn_fingerprint_t *fingerprint);

/**
 * Compare two fingerprints.
 *
 * # Arguments
 * * `a` - First fingerprint
 * * `b` - Second fingerprint
 *
 * # Returns
 * 1 if fingerprints match, 0 otherwise
 */
int mallorn_fingerprint_matches(const mallorn_fingerprint_t *a,
                                const mallorn_fingerprint_t *b);

/**
 * Compare a fingerprint against expected short ID.
 *
 * # Arguments
 * * `fp` - Fingerprint to check
 * * `expected_short_id` - Expected 8-byte short ID
 *
 * # Returns
 * 1 if short ID matches, 0 otherwise
 */
int mallorn_fingerprint_check(const mallorn_fingerprint_t *fp,
                              const uint8_t expected_short_id[8]);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif /* MALLORN_H */
